{"version":3,"file":"nuclen-tasks.js","sources":["../../../src/admin/ts/tasks.ts"],"sourcesContent":["/**\r\n * Nuclear Engagement Tasks Page JavaScript\r\n */\r\n\r\nimport { error, log } from '../../shared/logger';\r\n\r\ndeclare const ajaxurl: string;\r\ndeclare const nuclen_tasks: {\r\n    nonce: string;\r\n    i18n: {\r\n        processing: string;\r\n        cancelling: string;\r\n        error: string;\r\n        success: string;\r\n    };\r\n};\r\n\r\ninterface TaskData {\r\n    id: string;\r\n    workflow_type: string;\r\n    status: string;\r\n    progress: number;\r\n    details: string;\r\n    created_at: string;\r\n    scheduled_at?: string;\r\n    failed?: number;\r\n}\r\n\r\ninterface PollingConfig {\r\n    initialInterval: number;\r\n    intervals: Array<{ after: number; interval: number }>;\r\n    maxInterval: number;\r\n}\r\n\r\nclass TasksManager {\r\n    private isProcessing = false;\r\n    private isRefreshing = false;\r\n    private currentPage = 1;\r\n    \r\n    // Polling configuration\r\n    private pollingTimer: number | null = null;\r\n    private pollingStartTime: number = 0;\r\n    private isPageVisible = true;\r\n    private lastTasksData: Map<string, TaskData> = new Map();\r\n    private pollingConfig: PollingConfig = {\r\n        initialInterval: 15000, // 15 seconds\r\n        intervals: [\r\n            { after: 60000, interval: 30000 },    // After 1 minute, poll every 30s\r\n            { after: 300000, interval: 60000 },   // After 5 minutes, poll every 60s\r\n            { after: 600000, interval: 120000 },  // After 10 minutes, poll every 2 minutes\r\n        ],\r\n        maxInterval: 300000, // Max 5 minutes\r\n    };\r\n    \r\n    // Track active tasks for smart polling\r\n    private activeTasks = new Set<string>();\r\n    \r\n    // Auto-refresh UI elements\r\n    private pollingIndicator: HTMLElement | null = null;\r\n    private autoRefreshBanner: HTMLElement | null = null;\r\n    private nextPollTime: number = 0;\r\n    private countdownInterval: number | null = null;\r\n    \r\n    // Bound event handlers for cleanup\r\n    private handleVisibilityChange = this.onVisibilityChange.bind(this);\r\n    private handleWindowBlur = this.onWindowBlur.bind(this);\r\n    private handleWindowFocus = this.onWindowFocus.bind(this);\r\n\r\n    constructor() {\r\n        this.init();\r\n        \r\n        // Cleanup on page unload\r\n        window.addEventListener('beforeunload', () => {\r\n            this.cleanup();\r\n        });\r\n    }\r\n\r\n    private init(): void {\r\n        \r\n        // Check for recent completions on page load\r\n        this.checkRecentCompletions();\r\n        \r\n        // Attach event listeners to action buttons\r\n        this.attachActionHandlers();\r\n        \r\n        // Convert the refresh link to a button with AJAX functionality\r\n        this.setupRefreshButton();\r\n        \r\n        // Setup page visibility handling\r\n        this.setupPageVisibilityHandling();\r\n        \r\n        // Initialize task tracking\r\n        this.initializeTaskTracking();\r\n        \r\n        // Create polling indicator\r\n        this.createPollingIndicator();\r\n        \r\n        // Start smart polling\r\n        this.startSmartPolling();\r\n    }\r\n\r\n    private setupPageVisibilityHandling(): void {\r\n        // Use Page Visibility API to pause polling when tab is hidden\r\n        document.addEventListener('visibilitychange', this.handleVisibilityChange);\r\n        \r\n        // Also handle window focus/blur as backup\r\n        window.addEventListener('blur', this.handleWindowBlur);\r\n        window.addEventListener('focus', this.handleWindowFocus);\r\n    }\r\n    \r\n    private onVisibilityChange(): void {\r\n        this.isPageVisible = !document.hidden;\r\n        log(`Page visibility changed: ${this.isPageVisible ? 'visible' : 'hidden'}`);\r\n        \r\n        if (this.isPageVisible) {\r\n            // Resume polling when page becomes visible\r\n            if (this.activeTasks.size > 0) {\r\n                this.startSmartPolling();\r\n            }\r\n        } else {\r\n            // Pause polling when page is hidden\r\n            this.stopPolling();\r\n        }\r\n    }\r\n    \r\n    private onWindowBlur(): void {\r\n        this.isPageVisible = false;\r\n        this.stopPolling();\r\n    }\r\n    \r\n    private onWindowFocus(): void {\r\n        this.isPageVisible = true;\r\n        if (this.activeTasks.size > 0) {\r\n            // Immediately refresh when window regains focus\r\n            this.refreshTasksData().catch(err => {\r\n                error('Failed to refresh on focus:', err);\r\n            });\r\n            this.startSmartPolling();\r\n        }\r\n    }\r\n    \r\n    private initializeTaskTracking(): void {\r\n        // Track all current tasks and their states\r\n        const rows = document.querySelectorAll('.nuclen-tasks-table tbody tr');\r\n        rows.forEach(row => {\r\n            const taskId = row.getAttribute('data-task-id');\r\n            const statusCell = row.querySelector('.column-status');\r\n            if (taskId && statusCell) {\r\n                const statusText = statusCell.textContent?.toLowerCase() || '';\r\n                \r\n                // Track as active if processing, pending, or scheduled\r\n                if (statusText.includes('processing') || statusText.includes('pending') || statusText.includes('scheduled')) {\r\n                    this.activeTasks.add(taskId);\r\n                }\r\n                \r\n                // Store initial task data\r\n                this.lastTasksData.set(taskId, this.extractTaskDataFromRow(row as HTMLElement));\r\n            }\r\n        });\r\n        \r\n        log(`Initialized task tracking: ${this.activeTasks.size} active tasks`);\r\n    }\r\n    \r\n    private extractTaskDataFromRow(row: HTMLElement): TaskData {\r\n        const taskId = row.getAttribute('data-task-id') || '';\r\n        const statusCell = row.querySelector('.column-status');\r\n        const progressCell = row.querySelector('.column-progress');\r\n        const detailsCell = row.querySelector('td:nth-child(7)'); // Details column is now 7th\r\n        \r\n        // Extract progress number from progress bar\r\n        let progress = 0;\r\n        const progressText = progressCell?.querySelector('.nuclen-progress-text')?.textContent;\r\n        if (progressText) {\r\n            const match = progressText.match(/(\\d+)%/);\r\n            if (match) {\r\n                progress = parseInt(match[1], 10);\r\n            }\r\n        }\r\n        \r\n        return {\r\n            id: taskId,\r\n            workflow_type: row.querySelector('td:nth-child(4)')?.textContent || '', // Type column is now 4th\r\n            status: this.extractStatusFromBadge(statusCell?.innerHTML || ''),\r\n            progress: progress,\r\n            details: detailsCell?.innerHTML || '',\r\n            created_at: row.querySelector('td:nth-child(1)')?.textContent || '',\r\n            scheduled_at: row.querySelector('td:nth-child(2)')?.textContent || '',\r\n            failed: this.extractFailedCount(detailsCell?.innerHTML || ''),\r\n        };\r\n    }\r\n    \r\n    private extractStatusFromBadge(badgeHtml: string): string {\r\n        // Extract status from badge class\r\n        const match = badgeHtml.match(/nuclen-badge-(\\w+)/);\r\n        if (match) {\r\n            const badgeClass = match[1];\r\n            switch (badgeClass) {\r\n                case 'warning':\r\n                    return badgeHtml.includes('Pending') ? 'pending' : 'completed_with_errors';\r\n                case 'info':\r\n                    return 'processing';\r\n                case 'success':\r\n                    return 'completed';\r\n                case 'error':\r\n                    return 'failed';\r\n                default:\r\n                    return 'cancelled';\r\n            }\r\n        }\r\n        return 'unknown';\r\n    }\r\n    \r\n    private extractFailedCount(detailsHtml: string): number {\r\n        const match = detailsHtml.match(/(\\d+)\\s+failed/);\r\n        return match ? parseInt(match[1], 10) : 0;\r\n    }\r\n    \r\n    private cleanup(): void {\r\n        // Stop polling\r\n        this.stopPolling();\r\n        \r\n        // Clear countdown\r\n        if (this.countdownInterval) {\r\n            clearInterval(this.countdownInterval);\r\n            this.countdownInterval = null;\r\n        }\r\n        \r\n        // Remove polling indicator\r\n        if (this.pollingIndicator) {\r\n            this.pollingIndicator.remove();\r\n        }\r\n        \r\n        // Remove auto-refresh banner\r\n        if (this.autoRefreshBanner) {\r\n            this.autoRefreshBanner.remove();\r\n        }\r\n        \r\n        // Clear stored data to free memory\r\n        this.lastTasksData.clear();\r\n        this.activeTasks.clear();\r\n        \r\n        // Remove event listeners\r\n        document.removeEventListener('visibilitychange', this.handleVisibilityChange);\r\n        window.removeEventListener('blur', this.handleWindowBlur);\r\n        window.removeEventListener('focus', this.handleWindowFocus);\r\n    }\r\n    \r\n    private startSmartPolling(): void {\r\n        // Don't start if page is not visible or no active tasks\r\n        if (!this.isPageVisible || this.activeTasks.size === 0) {\r\n            this.updatePollingIndicator(false);\r\n            return;\r\n        }\r\n        \r\n        // Clear any existing timer\r\n        this.stopPolling();\r\n        \r\n        // Record polling start time\r\n        if (this.pollingStartTime === 0) {\r\n            this.pollingStartTime = Date.now();\r\n        }\r\n        \r\n        // Calculate appropriate interval based on elapsed time\r\n        const elapsedTime = Date.now() - this.pollingStartTime;\r\n        let interval = this.pollingConfig.initialInterval;\r\n        \r\n        for (const config of this.pollingConfig.intervals) {\r\n            if (elapsedTime > config.after) {\r\n                interval = config.interval;\r\n            }\r\n        }\r\n        \r\n        // Cap at max interval\r\n        interval = Math.min(interval, this.pollingConfig.maxInterval);\r\n        \r\n        log(`Starting smart polling with interval: ${interval / 1000}s, active tasks: ${this.activeTasks.size}`);\r\n        \r\n        // Update UI\r\n        this.nextPollTime = Date.now() + interval;\r\n        this.updatePollingIndicator(true, interval);\r\n        this.startCountdown();\r\n        \r\n        // Schedule next poll\r\n        this.pollingTimer = window.setTimeout(() => {\r\n            this.pollForUpdates();\r\n        }, interval);\r\n    }\r\n    \r\n    private stopPolling(): void {\r\n        if (this.pollingTimer) {\r\n            clearTimeout(this.pollingTimer);\r\n            this.pollingTimer = null;\r\n            log('Polling stopped');\r\n        }\r\n        \r\n        // Stop countdown\r\n        if (this.countdownInterval) {\r\n            clearInterval(this.countdownInterval);\r\n            this.countdownInterval = null;\r\n        }\r\n        \r\n        // Update UI\r\n        this.updatePollingIndicator(false);\r\n    }\r\n    \r\n    private async pollForUpdates(): Promise<void> {\r\n        if (!this.isPageVisible || this.isRefreshing) {\r\n            return;\r\n        }\r\n        \r\n        try {\r\n            log('Polling for task updates...');\r\n            \r\n            const response = await fetch(ajaxurl, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/x-www-form-urlencoded',\r\n                },\r\n                body: new URLSearchParams({\r\n                    action: 'nuclen_refresh_tasks_data',\r\n                    nonce: nuclen_tasks.nonce,\r\n                    page: this.currentPage.toString(),\r\n                })\r\n            });\r\n            \r\n            if (!response.ok) {\r\n                throw new Error(`HTTP error! status: ${response.status}`);\r\n            }\r\n            \r\n            const result = await response.json();\r\n            \r\n            if (result && result.success && result.data && Array.isArray(result.data.tasks)) {\r\n                this.updateTasksFromPolling(result.data.tasks);\r\n                \r\n                // Only show update indicator if tasks were actually updated\r\n                if (result.data.tasks.length > 0) {\r\n                    this.showUpdateIndicator();\r\n                }\r\n            }\r\n        } catch (err) {\r\n            error('Failed to poll for updates:', err);\r\n            // Don't stop polling on error, just skip this iteration\r\n        } finally {\r\n            // Continue polling if there are still active tasks\r\n            if (this.activeTasks.size > 0 && this.isPageVisible) {\r\n                this.startSmartPolling();\r\n            } else if (this.activeTasks.size === 0) {\r\n                log('No active tasks remaining, stopping polling');\r\n                this.pollingStartTime = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    private updateTasksFromPolling(newTasks: TaskData[]): void {\r\n        const updatedTasks = new Set<string>();\r\n        \r\n        // Limit stored tasks to prevent memory issues\r\n        const MAX_STORED_TASKS = 100;\r\n        if (this.lastTasksData.size > MAX_STORED_TASKS) {\r\n            // Remove old completed/cancelled tasks first\r\n            const tasksToRemove: string[] = [];\r\n            this.lastTasksData.forEach((task, id) => {\r\n                if (!this.activeTasks.has(id) && \r\n                    (task.status === 'completed' || task.status === 'cancelled' || task.status === 'failed')) {\r\n                    tasksToRemove.push(id);\r\n                }\r\n            });\r\n            \r\n            // Remove enough tasks to get under the limit\r\n            const removeCount = Math.min(tasksToRemove.length, this.lastTasksData.size - MAX_STORED_TASKS + 10); // +10 for buffer\r\n            tasksToRemove.slice(0, removeCount).forEach(id => this.lastTasksData.delete(id));\r\n        }\r\n        \r\n        newTasks.forEach(newTask => {\r\n            const oldTask = this.lastTasksData.get(newTask.id);\r\n            \r\n            // Check if task has changed\r\n            if (!oldTask || this.hasTaskChanged(oldTask, newTask)) {\r\n                // Update the DOM for this specific task\r\n                this.updateSingleTaskRow(newTask);\r\n                updatedTasks.add(newTask.id);\r\n                \r\n                // Update our stored data\r\n                this.lastTasksData.set(newTask.id, newTask);\r\n            }\r\n            \r\n            // Update active tasks tracking\r\n            if (newTask.status === 'processing' || newTask.status === 'pending' || newTask.status === 'scheduled') {\r\n                this.activeTasks.add(newTask.id);\r\n            } else {\r\n                this.activeTasks.delete(newTask.id);\r\n            }\r\n        });\r\n        \r\n        if (updatedTasks.size > 0) {\r\n            log(`Updated ${updatedTasks.size} tasks: ${Array.from(updatedTasks).join(', ')}`);\r\n        }\r\n    }\r\n    \r\n    private hasTaskChanged(oldTask: TaskData, newTask: TaskData): boolean {\r\n        return (\r\n            oldTask.status !== newTask.status ||\r\n            oldTask.progress !== newTask.progress ||\r\n            oldTask.failed !== newTask.failed ||\r\n            oldTask.details !== newTask.details\r\n        );\r\n    }\r\n    \r\n    private updateSingleTaskRow(task: TaskData): void {\r\n        const row = document.querySelector(`tr[data-task-id=\"${task.id}\"]`);\r\n        if (!row) return;\r\n        \r\n        // Update only the changed cells\r\n        this.updateTasksTable([task]);\r\n    }\r\n    \r\n    private showUpdateIndicator(): void {\r\n        // Find or create update indicator\r\n        let indicator = document.querySelector('.nuclen-update-indicator') as HTMLElement;\r\n        if (!indicator) {\r\n            indicator = document.createElement('div');\r\n            indicator.className = 'nuclen-update-indicator';\r\n            indicator.innerHTML = '<span class=\"dashicons dashicons-update spin\"></span> Updated';\r\n            \r\n            const pageTitle = document.querySelector('.wrap h1');\r\n            if (pageTitle) {\r\n                pageTitle.appendChild(indicator);\r\n            } else {\r\n                // Fallback: add to body if page title not found\r\n                document.body.appendChild(indicator);\r\n            }\r\n        }\r\n        \r\n        // Show indicator\r\n        indicator.classList.add('visible');\r\n        \r\n        // Hide after 2 seconds\r\n        setTimeout(() => {\r\n            if (indicator && indicator.parentNode) {\r\n                indicator.classList.remove('visible');\r\n            }\r\n        }, 2000);\r\n    }\r\n\r\n    private attachActionHandlers(): void {\r\n        // Handle run now buttons\r\n        document.querySelectorAll('.nuclen-run-now').forEach(button => {\r\n            button.addEventListener('click', (e) => this.handleRunTask(e));\r\n        });\r\n\r\n        // Handle cancel buttons\r\n        document.querySelectorAll('.nuclen-cancel').forEach(button => {\r\n            button.addEventListener('click', (e) => this.handleCancelTask(e));\r\n        });\r\n    }\r\n\r\n    private setupRefreshButton(): void {\r\n        // Find the refresh link\r\n        const refreshLink = document.querySelector('a[href*=\"refresh=1\"]');\r\n        if (!refreshLink) return;\r\n\r\n        // Get current page from URL if available\r\n        const urlParams = new URLSearchParams(window.location.search);\r\n        this.currentPage = parseInt(urlParams.get('paged') || '1', 10);\r\n\r\n        // Convert to button\r\n        const refreshButton = document.createElement('button');\r\n        refreshButton.className = 'button button-small nuclen-refresh-button';\r\n        refreshButton.innerHTML = '<span class=\"dashicons dashicons-update\"></span> Refresh';\r\n        refreshButton.title = 'Refresh task data';\r\n        \r\n        // Replace link with button\r\n        refreshLink.parentNode?.replaceChild(refreshButton, refreshLink);\r\n        \r\n        // Add click handler\r\n        refreshButton.addEventListener('click', (e) => {\r\n            e.preventDefault();\r\n            this.refreshTasksData();\r\n        });\r\n    }\r\n\r\n    private async refreshTasksData(): Promise<void> {\r\n        if (this.isRefreshing) return;\r\n        \r\n        this.isRefreshing = true;\r\n        \r\n        try {\r\n            // Add visual feedback\r\n            const refreshButton = document.querySelector('.nuclen-refresh-button');\r\n            if (refreshButton) {\r\n                refreshButton.classList.add('is-busy');\r\n                refreshButton.setAttribute('disabled', 'disabled');\r\n            }\r\n            \r\n            const response = await fetch(ajaxurl, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/x-www-form-urlencoded',\r\n                },\r\n                body: new URLSearchParams({\r\n                    action: 'nuclen_refresh_tasks_data',\r\n                    nonce: nuclen_tasks.nonce,\r\n                    page: this.currentPage.toString(),\r\n                })\r\n            });\r\n            \r\n            const result = await response.json();\r\n            \r\n            if (result.success && result.data && result.data.tasks) {\r\n                // Update all tasks\r\n                this.updateTasksFromPolling(result.data.tasks);\r\n                this.showNotice('Tasks refreshed successfully', 'success');\r\n                \r\n                // Reset polling timer since we just refreshed\r\n                this.pollingStartTime = Date.now();\r\n                if (this.activeTasks.size > 0) {\r\n                    this.startSmartPolling();\r\n                }\r\n            } else {\r\n                throw new Error(result.data?.message || 'Failed to refresh tasks');\r\n            }\r\n        } catch (err) {\r\n            error('Failed to refresh tasks:', err);\r\n            this.showNotice('Failed to refresh tasks. Please try again.', 'error');\r\n        } finally {\r\n            this.isRefreshing = false;\r\n            \r\n            // Remove visual feedback\r\n            const refreshButton = document.querySelector('.nuclen-refresh-button');\r\n            if (refreshButton) {\r\n                refreshButton.classList.remove('is-busy');\r\n                refreshButton.removeAttribute('disabled');\r\n            }\r\n        }\r\n    }\r\n\r\n    private updateTasksTable(tasks: TaskData[]): void {\r\n        const tbody = document.querySelector('.nuclen-tasks-table tbody');\r\n        if (!tbody || tasks.length === 0) return;\r\n\r\n        // Update each task row\r\n        tasks.forEach(task => {\r\n            const row = tbody.querySelector(`tr[data-task-id=\"${task.id}\"]`);\r\n            if (!row) return;\r\n\r\n            // Update status\r\n            const statusCell = row.querySelector('.column-status');\r\n            if (statusCell) {\r\n                statusCell.innerHTML = this.getStatusBadge(task.status);\r\n            }\r\n\r\n            // Update progress\r\n            const progressCell = row.querySelector('.column-progress');\r\n            if (progressCell) {\r\n                progressCell.innerHTML = `\r\n                    <div class=\"nuclen-progress-container\">\r\n                        <div class=\"nuclen-progress-bar\">\r\n                            <div class=\"nuclen-progress-fill\" style=\"width: ${task.progress}%\"></div>\r\n                        </div>\r\n                        <span class=\"nuclen-progress-text\">${task.progress}%</span>\r\n                    </div>\r\n                `;\r\n            }\r\n\r\n            // Update details\r\n            const detailsCell = row.querySelector('td:nth-child(7)'); // Details column is now 7th\r\n            if (detailsCell) {\r\n                let detailsHTML = task.details;\r\n                if (task.failed && task.failed > 0) {\r\n                    detailsHTML += `<br><span class=\"nuclen-error-text\">${task.failed} failed</span>`;\r\n                }\r\n                detailsCell.innerHTML = detailsHTML;\r\n            }\r\n\r\n\r\n            // Update actions based on status\r\n            this.updateActionButtons(row as HTMLElement, task.status);\r\n        });\r\n    }\r\n\r\n    private async handleRunTask(event: Event): Promise<void> {\r\n        event.preventDefault();\r\n        const button = event.currentTarget as HTMLElement;\r\n        const taskId = button.getAttribute('data-task-id');\r\n        \r\n        if (!taskId || this.isProcessing) return;\r\n        \r\n        await this.executeTaskAction('run_task', taskId, button);\r\n    }\r\n\r\n    private async handleCancelTask(event: Event): Promise<void> {\r\n        event.preventDefault();\r\n        const button = event.currentTarget as HTMLElement;\r\n        const taskId = button.getAttribute('data-task-id');\r\n        \r\n        if (!taskId || this.isProcessing) return;\r\n        \r\n        if (!window.confirm('Are you sure you want to cancel this task?')) {\r\n            return;\r\n        }\r\n        \r\n        await this.executeTaskAction('cancel_task', taskId, button);\r\n    }\r\n\r\n    private async executeTaskAction(action: string, taskId: string, button: HTMLElement): Promise<void> {\r\n        this.isProcessing = true;\r\n        const originalText = button.textContent || '';\r\n        const row = button.closest('tr');\r\n        \r\n        try {\r\n            // Update button state\r\n            button.classList.add('disabled');\r\n            button.setAttribute('disabled', 'disabled');\r\n            \r\n            if (action === 'run_task') {\r\n                button.textContent = nuclen_tasks.i18n.processing || 'Processing...';\r\n            } else {\r\n                button.textContent = nuclen_tasks.i18n.cancelling || 'Cancelling...';\r\n            }\r\n\r\n            // Make AJAX request\r\n            const response = await fetch(ajaxurl, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/x-www-form-urlencoded',\r\n                },\r\n                body: new URLSearchParams({\r\n                    action: `nuclen_${action}`,\r\n                    task_id: taskId,\r\n                    nonce: nuclen_tasks.nonce\r\n                })\r\n            });\r\n\r\n            const result = await response.json();\r\n\r\n            if (result.success) {\r\n                // Show success message\r\n                this.showNotice(result.data.message || nuclen_tasks.i18n.success, 'success');\r\n                \r\n                // Show additional notice about refreshing\r\n                if (action === 'run_task') {\r\n                    setTimeout(() => {\r\n                        this.showNotice('Task is now processing. Refresh later to see the latest progress.', 'info');\r\n                    }, 500);\r\n                }\r\n                \r\n                // Update the row status locally\r\n                if (row) {\r\n                    // For run_task, immediately show processing status\r\n                    if (action === 'run_task') {\r\n                        const statusCell = row.querySelector('.column-status');\r\n                        if (statusCell) {\r\n                            statusCell.innerHTML = this.getStatusBadge('processing');\r\n                        }\r\n                        // Update action buttons to show spinner\r\n                        this.updateActionButtons(row as HTMLElement, 'processing');\r\n                        \r\n                        // Track as active task and start polling\r\n                        this.activeTasks.add(taskId);\r\n                        this.startSmartPolling();\r\n                    } else if (action === 'cancel_task') {\r\n                        // For cancel, show cancelled status\r\n                        const statusCell = row.querySelector('.column-status');\r\n                        if (statusCell) {\r\n                            statusCell.innerHTML = this.getStatusBadge('cancelled');\r\n                        }\r\n                        // Remove action buttons\r\n                        const actionsCell = row.querySelector('.column-actions');\r\n                        if (actionsCell) {\r\n                            actionsCell.innerHTML = '<span class=\"nuclen-no-actions\">—</span>';\r\n                        }\r\n                        \r\n                        // Remove from active tasks\r\n                        this.activeTasks.delete(taskId);\r\n                    }\r\n                }\r\n            } else {\r\n                // Use generic error message for user display\r\n                const errorMessage = nuclen_tasks.i18n.error || 'An error occurred. Please try again.';\r\n                throw new Error(errorMessage);\r\n            }\r\n\r\n        } catch (err) {\r\n            error('Task action failed:', err);\r\n            // Always show generic error message to users\r\n            const userMessage = nuclen_tasks.i18n.error || 'An error occurred. Please try again.';\r\n            this.showNotice(userMessage, 'error');\r\n            \r\n            // Restore button state\r\n            button.textContent = originalText;\r\n            button.classList.remove('disabled');\r\n            button.removeAttribute('disabled');\r\n        } finally {\r\n            this.isProcessing = false;\r\n        }\r\n    }\r\n\r\n    private getStatusBadge(status: string): string {\r\n        const badges: Record<string, string> = {\r\n            'pending': '<span class=\"nuclen-badge nuclen-badge-warning\">Pending</span>',\r\n            'scheduled': '<span class=\"nuclen-badge nuclen-badge-warning\">Scheduled</span>',\r\n            'processing': '<span class=\"nuclen-badge nuclen-badge-info\">Processing</span>',\r\n            'completed': '<span class=\"nuclen-badge nuclen-badge-success\">Completed</span>',\r\n            'completed_with_errors': '<span class=\"nuclen-badge nuclen-badge-warning\">Completed with Errors</span>',\r\n            'failed': '<span class=\"nuclen-badge nuclen-badge-error\">Failed</span>',\r\n            'cancelled': '<span class=\"nuclen-badge nuclen-badge-default\">Cancelled</span>'\r\n        };\r\n        \r\n        return badges[status] || `<span class=\"nuclen-badge nuclen-badge-default\">${status}</span>`;\r\n    }\r\n\r\n    private updateActionButtons(row: HTMLElement, status: string): void {\r\n        const actionsCell = row.querySelector('.column-actions');\r\n        if (!actionsCell) return;\r\n\r\n        // Clear existing actions\r\n        actionsCell.innerHTML = '';\r\n\r\n        if (status === 'pending' || status === 'scheduled') {\r\n            const taskId = row.getAttribute('data-task-id');\r\n            if (taskId) {\r\n                actionsCell.innerHTML = `\r\n                    <button class=\"button button-small nuclen-run-now\" data-task-id=\"${taskId}\">\r\n                        Run Now\r\n                    </button>\r\n                    <button class=\"button button-small nuclen-cancel\" data-task-id=\"${taskId}\">\r\n                        Cancel\r\n                    </button>\r\n                `;\r\n                \r\n                // Re-attach event handlers\r\n                actionsCell.querySelector('.nuclen-run-now')?.addEventListener('click', (e) => this.handleRunTask(e));\r\n                actionsCell.querySelector('.nuclen-cancel')?.addEventListener('click', (e) => this.handleCancelTask(e));\r\n            }\r\n        } else if (status === 'processing') {\r\n            const taskId = row.getAttribute('data-task-id');\r\n            if (taskId) {\r\n                actionsCell.innerHTML = `\r\n                    <span class=\"spinner is-active\"></span>\r\n                    <button class=\"button button-small nuclen-cancel\" data-task-id=\"${taskId}\">\r\n                        Cancel\r\n                    </button>\r\n                `;\r\n                // Re-attach cancel event handler\r\n                actionsCell.querySelector('.nuclen-cancel')?.addEventListener('click', (e) => this.handleCancelTask(e));\r\n            }\r\n        } else {\r\n            actionsCell.innerHTML = '<span class=\"nuclen-no-actions\">—</span>';\r\n        }\r\n    }\r\n\r\n    private showNotice(message: string, type: 'success' | 'error' | 'info' = 'info'): void {\r\n        // Check if there's an existing notice container\r\n        let noticeContainer = document.querySelector('.nuclen-tasks-notices');\r\n        if (!noticeContainer) {\r\n            // Create notice container\r\n            noticeContainer = document.createElement('div');\r\n            noticeContainer.className = 'nuclen-tasks-notices';\r\n            const pageTitle = document.querySelector('.wrap h1');\r\n            if (pageTitle) {\r\n                pageTitle.insertAdjacentElement('afterend', noticeContainer);\r\n            }\r\n        }\r\n\r\n        // Create notice element\r\n        const notice = document.createElement('div');\r\n        notice.className = `notice notice-${type} is-dismissible`;\r\n        notice.innerHTML = `\r\n            <p>${message}</p>\r\n            <button type=\"button\" class=\"notice-dismiss\">\r\n                <span class=\"screen-reader-text\">Dismiss this notice.</span>\r\n            </button>\r\n        `;\r\n\r\n        // Add to container\r\n        noticeContainer.appendChild(notice);\r\n\r\n        // Handle dismiss\r\n        notice.querySelector('.notice-dismiss')?.addEventListener('click', () => {\r\n            notice.remove();\r\n        });\r\n\r\n        // Auto-dismiss after 5 seconds\r\n        setTimeout(() => {\r\n            notice.remove();\r\n        }, 5000);\r\n    }\r\n\r\n    \r\n    private async checkRecentCompletions(): Promise<void> {\r\n        try {\r\n            const response = await fetch(ajaxurl, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/x-www-form-urlencoded',\r\n                },\r\n                body: new URLSearchParams({\r\n                    action: 'nuclen_get_recent_completions',\r\n                    nonce: nuclen_tasks.nonce\r\n                })\r\n            });\r\n\r\n            const result = await response.json();\r\n            \r\n            if (result.success && result.data && result.data.length > 0) {\r\n                // Show notifications for recent completions\r\n                result.data.forEach((completion: any) => {\r\n                    // let message: string;\r\n                    // let type: 'success' | 'error' | 'info';\r\n                    \r\n                    if (completion.status === 'completed') {\r\n                        // message = `Generation ${completion.task_id} completed successfully!`;\r\n                        // type = 'success';\r\n                    } else if (completion.status === 'completed_with_errors') {\r\n                        // const failCount = completion.fail_count || 'some';\r\n                        // message = `Generation ${completion.task_id} completed with ${failCount} errors. Check individual posts for details.`;\r\n                        // type = 'info';\r\n                    } else if (completion.status === 'failed') {\r\n                        // message = `Generation ${completion.task_id} failed.`;\r\n                        // type = 'error';\r\n                    } else {\r\n                        return; // Skip unknown statuses\r\n                    }\r\n                    \r\n                    // Disabled for now - will be re-enabled later\r\n                    // this.showNotice(message, type);\r\n                });\r\n            }\r\n        } catch (err) {\r\n            error('Failed to check recent completions:', err);\r\n        }\r\n    }\r\n    \r\n    private createPollingIndicator(): void {\r\n        // Create the polling status indicator\r\n        const indicator = document.createElement('div');\r\n        indicator.className = 'nuclen-polling-indicator';\r\n        indicator.innerHTML = `\r\n            <span class=\"nuclen-polling-icon\">\r\n                <span class=\"dashicons dashicons-update\"></span>\r\n            </span>\r\n            <span class=\"nuclen-polling-text\">Auto-refresh: <span class=\"status\">Inactive</span></span>\r\n            <span class=\"nuclen-polling-countdown\"></span>\r\n        `;\r\n        \r\n        // Find the refresh button and insert indicator next to it\r\n        const refreshButton = document.querySelector('.nuclen-refresh-button');\r\n        \r\n        if (refreshButton && refreshButton.parentNode) {\r\n            refreshButton.parentNode.insertBefore(indicator, refreshButton.nextSibling);\r\n            this.pollingIndicator = indicator;\r\n        } else {\r\n            // Fallback: insert after the page title\r\n            const pageTitle = document.querySelector('.wrap h1');\r\n            if (pageTitle) {\r\n                pageTitle.appendChild(indicator);\r\n                this.pollingIndicator = indicator;\r\n            }\r\n        }\r\n        \r\n        // Create notification banner for auto-refresh\r\n        this.createAutoRefreshBanner();\r\n    }\r\n    \r\n    private createAutoRefreshBanner(): void {\r\n        const banner = document.createElement('div');\r\n        banner.className = 'nuclen-auto-refresh-banner';\r\n        banner.innerHTML = `\r\n            <span class=\"dashicons dashicons-update\"></span>\r\n            <span>Auto-refresh active</span>\r\n        `;\r\n        document.body.appendChild(banner);\r\n        this.autoRefreshBanner = banner;\r\n    }\r\n    \r\n    private updatePollingIndicator(active: boolean, interval?: number): void {\r\n        if (!this.pollingIndicator) return;\r\n        \r\n        const statusEl = this.pollingIndicator.querySelector('.status') as HTMLElement;\r\n        const iconEl = this.pollingIndicator.querySelector('.nuclen-polling-icon') as HTMLElement;\r\n        const countdownEl = this.pollingIndicator.querySelector('.nuclen-polling-countdown') as HTMLElement;\r\n        \r\n        if (active) {\r\n            this.pollingIndicator.classList.add('active');\r\n            statusEl.textContent = `Active (${this.activeTasks.size} task${this.activeTasks.size !== 1 ? 's' : ''})`;\r\n            iconEl.classList.add('spin');\r\n            \r\n            if (interval) {\r\n                const seconds = Math.floor(interval / 1000);\r\n                countdownEl.textContent = `Next refresh in ${seconds}s`;\r\n            }\r\n            \r\n            // Show the auto-refresh banner briefly when first activated\r\n            if (this.autoRefreshBanner && !this.pollingIndicator.classList.contains('active')) {\r\n                this.autoRefreshBanner.classList.add('show');\r\n                // Auto-hide after 3 seconds\r\n                setTimeout(() => {\r\n                    if (this.autoRefreshBanner) {\r\n                        this.autoRefreshBanner.classList.remove('show');\r\n                    }\r\n                }, 3000);\r\n            }\r\n        } else {\r\n            this.pollingIndicator.classList.remove('active');\r\n            statusEl.textContent = 'Inactive';\r\n            iconEl.classList.remove('spin');\r\n            countdownEl.textContent = '';\r\n            \r\n            // Hide the auto-refresh banner\r\n            if (this.autoRefreshBanner) {\r\n                this.autoRefreshBanner.classList.remove('show');\r\n            }\r\n        }\r\n    }\r\n    \r\n    private startCountdown(): void {\r\n        // Clear any existing countdown\r\n        if (this.countdownInterval) {\r\n            clearInterval(this.countdownInterval);\r\n        }\r\n        \r\n        this.countdownInterval = window.setInterval(() => {\r\n            const remaining = Math.max(0, Math.floor((this.nextPollTime - Date.now()) / 1000));\r\n            const countdownEl = this.pollingIndicator?.querySelector('.nuclen-polling-countdown') as HTMLElement;\r\n            \r\n            if (countdownEl) {\r\n                if (remaining > 0) {\r\n                    countdownEl.textContent = `Next refresh in ${remaining}s`;\r\n                } else {\r\n                    countdownEl.textContent = 'Refreshing...';\r\n                }\r\n            }\r\n            \r\n            if (remaining <= 0 && this.countdownInterval) {\r\n                clearInterval(this.countdownInterval);\r\n                this.countdownInterval = null;\r\n            }\r\n        }, 1000);\r\n    }\r\n}\r\n\r\n// Initialize when DOM is ready\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n    try {\r\n        new TasksManager();\r\n    } catch (error) {\r\n        // Silently fail\r\n    }\r\n});\r\n\r\n// Export for testing\r\nexport default TasksManager;"],"names":["TasksManager","__publicField","log","err","error","row","taskId","statusCell","statusText","_a","progressCell","detailsCell","progress","progressText","match","_b","_c","_d","badgeHtml","detailsHtml","elapsedTime","interval","config","response","result","newTasks","updatedTasks","MAX_STORED_TASKS","tasksToRemove","task","id","removeCount","newTask","oldTask","indicator","pageTitle","button","e","refreshLink","urlParams","refreshButton","tasks","tbody","detailsHTML","event","action","originalText","actionsCell","errorMessage","userMessage","status","message","type","noticeContainer","notice","completion","banner","active","statusEl","iconEl","countdownEl","seconds","remaining"],"mappings":"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"}