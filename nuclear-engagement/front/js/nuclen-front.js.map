{"version":3,"mappings":";ovCAaA,OAAO,wBAA0B,SAChCA,EACAC,EAAkC,KACjC,CACD,MAAMC,EAAY,SAAS,eAAeF,CAAW,EACrD,GAAI,CAACE,EAAW,OAEhB,MAAMC,EAAW,IAAI,qBACnBC,GAAY,CACZA,EAAQ,QAASC,GAAU,CAC1B,GAAIA,EAAM,eAAgB,CACzB,MAAMC,EAAM,OACRL,GAAoB,OAAOK,EAAIL,CAAgB,GAAM,YACvDK,EAAIL,CAAgB,IAEtBE,EAAS,YAAW,CACrB,CACA,GAEF,CACC,WAAY,qBACZ,UAAW,GACZ,EAGDA,EAAS,QAAQD,CAAS,CAC3B,EAKA,SAASK,EAA+BC,EAAkBC,EAAuB,CAChF,MAAMC,EAAS,SAAS,cAAcF,CAAQ,EAC9C,GAAI,CAACE,EAAQ,OAEI,IAAI,qBACpB,CAACN,EAASO,IAAQ,CACjBP,EAAQ,QAASC,GAAU,CAEtBA,EAAM,gBAAkBA,EAAM,oBAAsB,IACnD,OAAO,MAAS,YACnB,KAAK,QAASI,CAAa,EAG5BE,EAAI,UAAUN,EAAM,MAAM,EAC3B,CACA,GAEF,CACC,KAAM,KACN,WAAY,MACZ,UAAW,EACZ,EAGQ,QAAQK,CAAM,CACxB,CAKA,MAAME,EAAc,IAAI,iBAAiB,CAACC,EAAYF,IAAQ,CAC7D,MAAMG,EAAS,SAAS,eAAe,uBAAuB,EACxDC,EAAY,SAAS,eAAe,0BAA0B,EAChED,GAAUC,IACbR,EAA+B,4BAA6B,qBAAqB,EACjFA,EAA+B,yBAA0B,kBAAkB,EAC3EI,EAAI,aAEN,CAAC,EACDC,EAAY,QAAQ,SAAS,KAAM,CAAE,UAAW,GAAM,QAAS,GAAM,EAGrE,MAAMI,EAAkB,IAAM,CAC7BJ,EAAY,YACb,EAEI,eAAgB,OACnB,OAAO,iBAAiB,WAAYI,CAAe,EAEnD,OAAO,iBAAiB,eAAgBA,CAAe,EAMxD,OAAO,0BAA4B,SAAY,CAC9C,GAAI,CACH,KAAM,CAAE,SAAAC,CAAA,EAAa,MAAAC,EAAA,yBAAAD,GAAA,KAAM,QAAO,uCAAoB,+BAAAA,CAAA,2BACtDA,EAAA,CAAS,OACDE,EAAO,CACf,QAAQ,MAAM,8BAA+BA,CAAK,EAEpD,EAKA,OAAO,wBAAwB,wBAAyB,2BAA2B","names":["containerId","initFunctionName","component","observer","entries","entry","win","nuclenInitIntersectionObserver","selector","gtagEventName","target","obs","mutationObs","_mutations","quizEl","summaryEl","cleanupObserver","initQuiz","__vitePreload","error"],"ignoreList":[],"sources":["../../../src/front/ts/nuclen-front-lazy.ts"],"sourcesContent":["// nuclen-front-lazy.ts\r\n\r\n/*************************************************\r\n* 2) Lazy-Load + GA Intersection Observers\r\n*\r\n* Using IntersectionObserver delays expensive quiz\r\n* initialization until the component scrolls into view.\r\n* This minimizes network requests on initial page load.\r\n*************************************************/\r\n\r\n/**\r\n * 2a) Lazy-load container. Observes 'containerId' and triggers `initFunctionName` once visible.\r\n */\r\nwindow.NuclenLazyLoadComponent = function (\r\n\tcontainerId: string,\r\n\tinitFunctionName: string | null = null,\r\n) {\r\n\tconst component = document.getElementById(containerId);\r\n\tif (!component) return;\r\n\r\n\tconst observer = new IntersectionObserver(\r\n\t\t(entries) => {\r\n\t\t\tentries.forEach((entry) => {\r\n\t\t\t\tif (entry.isIntersecting) {\r\n\t\t\t\t\tconst win = window as unknown as Record<string, unknown>;\r\n\t\t\t\t\tif (initFunctionName && typeof win[initFunctionName] === 'function') {\r\n\t\t\t\t\t\t(win[initFunctionName] as () => void)();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tobserver.disconnect();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\t{\r\n\t\t\trootMargin: '0px 0px -200px 0px',\r\n\t\t\tthreshold: 0.1\r\n\t\t}\r\n\t);\r\n\r\n\tobserver.observe(component);\r\n};\r\n\r\n/**\r\n\t * 2b) Fire a GA event when a specific element is fully in view (threshold=1.0).\r\n\t */\r\nfunction nuclenInitIntersectionObserver(selector: string, gtagEventName: string) {\r\n\tconst target = document.querySelector(selector);\r\n\tif (!target) return;\r\n\r\n\tconst observer = new IntersectionObserver(\r\n\t\t(entries, obs) => {\r\n\t\t\tentries.forEach((entry) => {\r\n\t\t\t// intersectionRatio === 1 means the element is fully in view\r\n\t\t\t\tif (entry.isIntersecting && entry.intersectionRatio === 1) {\r\n\t\t\t\t\tif (typeof gtag === 'function') {\r\n\t\t\t\t\t\tgtag('event', gtagEventName);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Stop observing after first event\r\n\t\t\t\t\tobs.unobserve(entry.target);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\t{\r\n\t\t\troot: null,\r\n\t\t\trootMargin: '0px',\r\n\t\t\tthreshold: 1.0 // require 100% of the element to be visible\r\n\t\t}\r\n\t);\r\n\r\n\tobserver.observe(target);\r\n}\r\n\r\n/**\r\n\t * 2c) Wait for #nuclen-quiz-container and #nuclen-summary-container in DOM, then attach GA observers.\r\n\t */\r\nconst mutationObs = new MutationObserver((_mutations, obs) => {\r\n\tconst quizEl = document.getElementById('nuclen-quiz-container');\r\n\tconst summaryEl = document.getElementById('nuclen-summary-container');\r\n\tif (quizEl && summaryEl) {\r\n\t\tnuclenInitIntersectionObserver('#nuclen-summary-container', 'nuclen_summary_view');\r\n\t\tnuclenInitIntersectionObserver('#nuclen-quiz-container', 'nuclen_quiz_view');\r\n\t\tobs.disconnect(); // stop once attached\r\n\t}\r\n});\r\nmutationObs.observe(document.body, { childList: true, subtree: true });\r\n\r\n// Ensure observer is disconnected on page navigation\r\nconst cleanupObserver = () => {\r\n\tmutationObs.disconnect();\r\n};\r\n\r\nif ('onpagehide' in window) {\r\n\twindow.addEventListener('pagehide', cleanupObserver);\r\n} else {\r\n\twindow.addEventListener('beforeunload', cleanupObserver);\r\n}\r\n\r\n/**\r\n\t * 2d) Set up dynamic quiz loading\r\n\t */\r\nwindow.nuclearEngagementInitQuiz = async () => {\r\n\ttry {\r\n\t\tconst { initQuiz } = await import('./nuclen-quiz-main');\r\n\t\tinitQuiz();\r\n\t} catch (error) {\r\n\t\tconsole.error('Failed to load quiz module:', error);\r\n\t}\r\n};\r\n\r\n/**\r\n\t * 2e) Immediately call lazy-loading for the quiz container, telling it to run nuclearEngagementInitQuiz() once in view.\r\n\t */\r\nwindow.NuclenLazyLoadComponent('nuclen-quiz-container', 'nuclearEngagementInitQuiz');\r\n"],"file":"front/js/nuclen-front.js"}