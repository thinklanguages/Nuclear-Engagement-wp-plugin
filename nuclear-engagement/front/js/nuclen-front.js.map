{"version":3,"mappings":";ovCAaA,OAAO,wBAA0B,SAChCA,EACAC,EAAkC,KACjC,CACD,MAAMC,EAAY,SAAS,eAAeF,CAAW,EACrD,GAAI,CAACE,EAAW,OAEhB,MAAMC,EAAW,IAAI,qBACnBC,GAAY,CACZA,EAAQ,QAASC,GAAU,CAC1B,GAAIA,EAAM,eAAgB,CACzB,MAAMC,EAAM,OACRL,GAAoB,OAAOK,EAAIL,CAAgB,GAAM,YACvDK,EAAIL,CAAgB,IAEtBE,EAAS,YAAW,CACrB,CACA,GAEF,CACC,WAAY,qBACZ,UAAW,GACZ,EAGDA,EAAS,QAAQD,CAAS,CAC3B,EAKA,SAASK,EAA+BC,EAAkBC,EAAuB,CAChF,MAAMC,EAAS,SAAS,cAAcF,CAAQ,EAC9C,GAAI,CAACE,EAAQ,OAEI,IAAI,qBACpB,CAACN,EAASO,IAAQ,CACjBP,EAAQ,QAASC,GAAU,CAEtBA,EAAM,gBAAkBA,EAAM,oBAAsB,IACnD,OAAO,MAAS,YACnB,KAAK,QAASI,CAAa,EAG5BE,EAAI,UAAUN,EAAM,MAAM,EAC3B,CACA,GAEF,CACC,KAAM,KACN,WAAY,MACZ,UAAW,EACZ,EAGQ,QAAQK,CAAM,CACxB,CAKA,MAAME,EAAc,IAAI,iBAAiB,CAACC,EAAYF,IAAQ,CAC7D,MAAMG,EAAS,SAAS,eAAe,uBAAuB,EACxDC,EAAY,SAAS,eAAe,0BAA0B,EAChED,GAAUC,IACbR,EAA+B,4BAA6B,qBAAqB,EACjFA,EAA+B,yBAA0B,kBAAkB,EAC3EI,EAAI,aAEN,CAAC,EACDC,EAAY,QAAQ,SAAS,KAAM,CAAE,UAAW,GAAM,QAAS,GAAM,EAGrE,MAAMI,EAAkB,IAAM,CAC7BJ,EAAY,YACb,EAEI,eAAgB,OACnB,OAAO,iBAAiB,WAAYI,CAAe,EAElD,OAAkB,iBAAiB,eAAgBA,CAAe,EAMpE,OAAO,0BAA4B,SAAY,CAC9C,GAAI,CACH,KAAM,CAAE,SAAAC,CAAA,EAAa,MAAAC,EAAA,yBAAAD,GAAA,KAAM,QAAO,uCAAoB,+BAAAA,CAAA,2BACtDA,EAAA,CAAS,MACM,EAGjB,EAKA,OAAO,wBAAwB,wBAAyB,2BAA2B","names":["containerId","initFunctionName","component","observer","entries","entry","win","nuclenInitIntersectionObserver","selector","gtagEventName","target","obs","mutationObs","_mutations","quizEl","summaryEl","cleanupObserver","initQuiz","__vitePreload"],"ignoreList":[],"sources":["../../../src/front/ts/nuclen-front-lazy.ts"],"sourcesContent":["// nuclen-front-lazy.ts\n\n/*************************************************\n* 2) Lazy-Load + GA Intersection Observers\n*\n* Using IntersectionObserver delays expensive quiz\n* initialization until the component scrolls into view.\n* This minimizes network requests on initial page load.\n*************************************************/\n\n/**\n * 2a) Lazy-load container. Observes 'containerId' and triggers `initFunctionName` once visible.\n */\nwindow.NuclenLazyLoadComponent = function (\n\tcontainerId: string,\n\tinitFunctionName: string | null = null,\n) {\n\tconst component = document.getElementById(containerId);\n\tif (!component) return;\n\n\tconst observer = new IntersectionObserver(\n\t\t(entries) => {\n\t\t\tentries.forEach((entry) => {\n\t\t\t\tif (entry.isIntersecting) {\n\t\t\t\t\tconst win = window as unknown as Record<string, unknown>;\n\t\t\t\t\tif (initFunctionName && typeof win[initFunctionName] === 'function') {\n\t\t\t\t\t\t(win[initFunctionName] as () => void)();\n\t\t\t\t\t}\n\t\t\t\t\tobserver.disconnect();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t{\n\t\t\trootMargin: '0px 0px -200px 0px',\n\t\t\tthreshold: 0.1\n\t\t}\n\t);\n\n\tobserver.observe(component);\n};\n\n/**\n\t * 2b) Fire a GA event when a specific element is fully in view (threshold=1.0).\n\t */\nfunction nuclenInitIntersectionObserver(selector: string, gtagEventName: string) {\n\tconst target = document.querySelector(selector);\n\tif (!target) return;\n\n\tconst observer = new IntersectionObserver(\n\t\t(entries, obs) => {\n\t\t\tentries.forEach((entry) => {\n\t\t\t// intersectionRatio === 1 means the element is fully in view\n\t\t\t\tif (entry.isIntersecting && entry.intersectionRatio === 1) {\n\t\t\t\t\tif (typeof gtag === 'function') {\n\t\t\t\t\t\tgtag('event', gtagEventName);\n\t\t\t\t\t}\n\t\t\t\t\t// Stop observing after first event\n\t\t\t\t\tobs.unobserve(entry.target);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t{\n\t\t\troot: null,\n\t\t\trootMargin: '0px',\n\t\t\tthreshold: 1.0 // require 100% of the element to be visible\n\t\t}\n\t);\n\n\tobserver.observe(target);\n}\n\n/**\n\t * 2c) Wait for #nuclen-quiz-container and #nuclen-summary-container in DOM, then attach GA observers.\n\t */\nconst mutationObs = new MutationObserver((_mutations, obs) => {\n\tconst quizEl = document.getElementById('nuclen-quiz-container');\n\tconst summaryEl = document.getElementById('nuclen-summary-container');\n\tif (quizEl && summaryEl) {\n\t\tnuclenInitIntersectionObserver('#nuclen-summary-container', 'nuclen_summary_view');\n\t\tnuclenInitIntersectionObserver('#nuclen-quiz-container', 'nuclen_quiz_view');\n\t\tobs.disconnect(); // stop once attached\n\t}\n});\nmutationObs.observe(document.body, { childList: true, subtree: true });\n\n// Ensure observer is disconnected on page navigation\nconst cleanupObserver = () => {\n\tmutationObs.disconnect();\n};\n\nif ('onpagehide' in window) {\n\twindow.addEventListener('pagehide', cleanupObserver);\n} else {\n\t(window as Window).addEventListener('beforeunload', cleanupObserver);\n}\n\n/**\n\t * 2d) Set up dynamic quiz loading\n\t */\nwindow.nuclearEngagementInitQuiz = async () => {\n\ttry {\n\t\tconst { initQuiz } = await import('./nuclen-quiz-main');\n\t\tinitQuiz();\n\t} catch (error) {\n\t\t// Failed to load quiz module\n\t}\n};\n\n/**\n\t * 2e) Immediately call lazy-loading for the quiz container, telling it to run nuclearEngagementInitQuiz() once in view.\n\t */\nwindow.NuclenLazyLoadComponent('nuclen-quiz-container', 'nuclearEngagementInitQuiz');\n"],"file":"front/js/nuclen-front.js"}